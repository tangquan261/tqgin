// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Squart.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Squart.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - SquartRoot

@implementation SquartRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SquartRoot_FileDescriptor

static GPBFileDescriptor *SquartRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"login"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - TagInfo

@implementation TagInfo

@dynamic id_p;
@dynamic tagName;

typedef struct TagInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *tagName;
  int64_t id_p;
} TagInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = TagInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TagInfo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tagName",
        .dataTypeSpecific.className = NULL,
        .number = TagInfo_FieldNumber_TagName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TagInfo__storage_, tagName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TagInfo class]
                                     rootClass:[SquartRoot class]
                                          file:SquartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TagInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000ID\000\002G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TagsInfo

@implementation TagsInfo

@dynamic tagInfoArray, tagInfoArray_Count;

typedef struct TagsInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tagInfoArray;
} TagsInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TagInfo),
        .number = TagsInfo_FieldNumber_TagInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TagsInfo__storage_, tagInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TagsInfo class]
                                     rootClass:[SquartRoot class]
                                          file:SquartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TagsInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000TagInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HotRoomInfo

@implementation HotRoomInfo

@dynamic roomId;
@dynamic roomTagName;
@dynamic roomHot;

typedef struct HotRoomInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *roomTagName;
  int64_t roomId;
  int64_t roomHot;
} HotRoomInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = HotRoomInfo_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HotRoomInfo__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "roomTagName",
        .dataTypeSpecific.className = NULL,
        .number = HotRoomInfo_FieldNumber_RoomTagName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HotRoomInfo__storage_, roomTagName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomHot",
        .dataTypeSpecific.className = NULL,
        .number = HotRoomInfo_FieldNumber_RoomHot,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HotRoomInfo__storage_, roomHot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HotRoomInfo class]
                                     rootClass:[SquartRoot class]
                                          file:SquartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HotRoomInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001EA\000\002K\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HotRooms

@implementation HotRooms

@dynamic hotRoomInfoArray, hotRoomInfoArray_Count;

typedef struct HotRooms__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hotRoomInfoArray;
} HotRooms__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hotRoomInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(HotRoomInfo),
        .number = HotRooms_FieldNumber_HotRoomInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(HotRooms__storage_, hotRoomInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HotRooms class]
                                     rootClass:[SquartRoot class]
                                          file:SquartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HotRooms__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000HotRoomInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BannerInfo

@implementation BannerInfo

@dynamic bannerId;
@dynamic targetType;
@dynamic startTime;
@dynamic endTime;
@dynamic bgImg;
@dynamic clickURL;

typedef struct BannerInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t bannerId;
  int32_t targetType;
  NSString *bgImg;
  NSString *clickURL;
  int64_t startTime;
  int64_t endTime;
} BannerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bannerId",
        .dataTypeSpecific.className = NULL,
        .number = BannerInfo_FieldNumber_BannerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BannerInfo__storage_, bannerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.className = NULL,
        .number = BannerInfo_FieldNumber_TargetType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BannerInfo__storage_, targetType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = BannerInfo_FieldNumber_StartTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BannerInfo__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = BannerInfo_FieldNumber_EndTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BannerInfo__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "bgImg",
        .dataTypeSpecific.className = NULL,
        .number = BannerInfo_FieldNumber_BgImg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BannerInfo__storage_, bgImg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clickURL",
        .dataTypeSpecific.className = NULL,
        .number = BannerInfo_FieldNumber_ClickURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BannerInfo__storage_, clickURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BannerInfo class]
                                     rootClass:[SquartRoot class]
                                          file:SquartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BannerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\006\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Banners

@implementation Banners

@dynamic bannerInfoArray, bannerInfoArray_Count;

typedef struct Banners__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *bannerInfoArray;
} Banners__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bannerInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BannerInfo),
        .number = Banners_FieldNumber_BannerInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Banners__storage_, bannerInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Banners class]
                                     rootClass:[SquartRoot class]
                                          file:SquartRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Banners__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000BannerInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
